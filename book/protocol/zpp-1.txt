========================================================
Zerograph Presentation Protocol (ZPP), version 1 (draft)
(C) Copyright 2014, Nigel Small <nigel@nigelsmall.com>
========================================================


Introduction
============
The Zerograph Presentation Protocol (ZPP) is an OSI level 6 text-based
request-response protocol that is used to define communications between 
client applications that require a graph database and server applications
that provide a Neo4j data store.

The reference implementation for ZPP - the Zerograph server bundle - transmits
all messages over ZeroMQ. This means of transmission is independent to the
protocol however and any request-response mechanism that supports textual
messaging should be able to support ZPP.

This specification is intended to be used in conjunction with a corresponding
application level protocol, generally the Zerograph Application Protocol (ZAP).


Encoding
========
All requests and responses MUST only use characters from the basic ASCII set,
i.e. 0x00 to 0x7F. Extended characters can be represented with the appropriate
JSON or YAML encoding: generally the "\uXXXX" sequence.


End of Line Sequences
=====================
Lines may be separated by any common end-of-line sequence as defined below:

eol := <CR> | <LF> | <CR><LF>


General Request/Response Layout
===============================
At the highest level, ZPP clients package a number of individual requests into
a request batch, one per line. These include a JSON payload which MUST not
contain any end of line sequences itself so as to avoid ambiguity. Responses
are encoded using YAML and contain one document per request line. A final,
optional response document MAY be appended if required. This could contain
summary or error information for the entire batch.

This document specifies no explicit correspondence between a request batch and
any underlying database transactions or other state. The framing of messages
is likewise unspecified and request and response batches may be transmitted in
multiple parts or in a single part as necessary. An implementation MAY also
allow responses to start transmission before the corresponding request has
been fully received. This capability will of course be dependent on support
from the underlying transmission protocol.


Requests
========
Each individual request within a batch occupies a single line and comprises
two mandatory elements and one optional element, each separated by single space
characters. Blank lines and a trailing end-of-line sequence MAY be included but
should be ignored by the receiving server.

The precise layout of a request batch (ignoring blank lines) is described
below:

request_batch := request [eol request]* [eol]
request       := method <SP> resource [<SP> arguments]
method        := <ALPHA>+
resource      := (<ALPHA> | "_") (<ALPHA> | <DIGIT> | "_")*
arguments     := <JSON_OBJECT>

Specific method and resource terms are defined by a corresponding application
level protocol but - by convention - methods SHOULD be encoded in upper case
and resources in camel case. End of line characters within the JSON arguments
are expressly forbidden to avoid ambiguities with individual request
delimitation.


Responses
=========
A response batch consists of a sequence of YAML documents, one for each request
sent in the corresponding request batch. A final document may also be included
which could, for example, contain a statistical summary of the batch's
execution or any relevant warnings or errors. If omitted, an empty summary
document may be inferred.

Each YAML response document - separated by the "---" sequence - should consist
of a single block style mapping. Within this mapping, four possible keys are
permitted: "head", "body", foot" and "error". Although these are all optional,
they MUST appear in this order whenever used. That is: if the "head" key is
provided, it MUST precede the "body" key and the "foot" key MUST follow the
"body" key in a similar way. If included, the "error" key SHOULD terminate the
response. This means that a response containing only an "error" key is valid.

Other documents may follow an "error" key but any information following an
"error" within the same document SHOULD be ignored by the client application.
This should also apply to any keys returned in a response other than the ones
specified here.

The values attached to each key are left for definition by the corresponding
application protocol and may be scalar values or YAML collections in either
flow or block style. When block style is used, an indentation level of two
spaces is preferred.

The precise layout of a response batch is described below:

response_batch   := response ["---" response]*
response         := [head] [body] [foot] [error]
head             := "head:" [<SP>] <YAML_MAPPING> eol
body             := "body:" [<SP>] <YAML_VALUE> eol
foot             := "foot:" [<SP>] <YAML_MAPPING> eol
error            := "error:" [<SP>] <YAML_VALUE> eol


Example
========
The example below shows example request and response batches:

Request
-------
CREATE Thing {"label": "foo", "size": 13}
GET Things {"label": "foo"}

Response
--------
body: !Thing {"id": 42, "label": "foo", "size": 13}
foot: {"stats": {"things_created": 1}}
---
body:
  - !Thing {"id": 41, "label": "foo", "size": 1006}
  - !Thing {"id": 42, "label": "foo", "size": 13}
  - !Thing {"id": 43, "label": "foo", "size": -4}
foot: {"stats": {"things_found": 3}}


References
==========
- JSON specification, 1st edition
  <http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf>
- YAML specification, version 1.2
  <http://www.yaml.org/spec/1.2/spec.html>
